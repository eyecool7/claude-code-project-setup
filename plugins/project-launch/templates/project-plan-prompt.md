# 프로젝트 계획서 작성 방법
이 문서는 사용자가 claude.ai 채팅창에서 바로 사용 가능한 '프로젝트 계획서 작성 프롬프트'를 제공하고 사용 방법을 설명한다.

## 사용 방법
1. project-plan-prompt.md를 열어서 [프로젝트 이름]과 프로젝트 개요를 채우세요.
2. 프롬프트 전체 내용을 claude.ai 채팅창에 붙여넣고 대화하며 계획서를 완성하세요.
3. 완성된 계획서를 project-plan.md로 저장하고 프로젝트 루트에 넣으세요.
4. /project-launch:refine 명령어를 실행하여 다음 단계로 넘어갑니다.

---

# 프로젝트 계획서 작성 프롬프트 (아래 전체를 claude.ai 채팅창에 전달)
나는 [프로젝트 이름]을 만들려고 해. 대략의 프로젝트 개요는 다음과 같아.

## 프로젝트 개요
- 수행 작업:
- 워크플로우:


## 최종 산출물

1개의 md 파일 **project-plan.md** — 제품 정의부터 구현 설계까지 담긴 통합 계획서.
이 문서는 claude-code-project-launch 스킬의 입력으로 사용된다.

## 계획서에 포함될 내용

### 1. 제품 컨텍스트

#### 한 줄 요약
이 프로젝트가 뭔지 한 문장.

#### 배경 및 목적
- 왜 만드는가? 어떤 문제를 해결하는가?
- 사용자는 누구인가? (역할이 여러 개면 각각 정의)

#### 핵심 기능 (3-7개)
기능별로:
- 기능명
- 설명 (1-2문장)
- 사용자 시나리오 (누가, 언제, 어떻게)
- 성공 기준 (구체적, 검증 가능 — "잘 동작한다" ❌ → "3초 내 응답" ✅)
- 우선순위 (P0 필수 / P1 중요 / P2 있으면 좋음)

#### 성공 기준 (Done의 정의)
이 체크리스트가 전부 ✅이면 MVP 완성:
- (P0 기능별 검증 가능한 조건)
- (비기능 충족 조건)

#### 비기능 요구사항
해당하는 것만: 성능, 보안, 접근성, SEO, 확장성

#### 범위 밖
이번에 명시적으로 안 만드는 것.

---

### 2. 워크플로우 정의

#### 사용자 플로우
[시작] → [단계1] → [단계2] → ... → [완료]
주요 분기점과 조건을 명시.

#### 에이전트 (LLM) 판단 vs 스크립트 (Claude Code)처리

| 에이전트가 직접 수행 | 스크립트로 처리 |
|---------------------|----------------|
| 분류, 의사결정, 우선순위 판단 | 파일 I/O, 데이터 파싱 |
| 품질 평가, 정성적 분석 | 외부 API 호출 |
| 컨텍스트 기반 추론 | 반복 처리, 집계 |
| 자연어 생성/요약 | 정적 분석, 테스트 실행 |

#### 단계별 검증

각 워크플로우 단계에 성공 기준 + 검증 방법 + 실패 처리를 명시.

검증 유형:
| 유형 | 적용 대상 | 예시 |
|------|----------|------|
| 스키마 검증 | 구조화된 산출물 | 필수 필드 존재, 타입 체크 |
| 규칙 기반 | 정량 기준이 있는 작업 | 항목 수, 글자 수 |
| LLM 자기 검증 | 정성적 판단 작업 | 요약 품질, 톤 적합성 |
| 사람 검토 | 고위험 최종 산출물 | 외부 발송 문서 |

실패 처리:
| 방식 | 사용 시점 |
|------|----------|
| 자동 재시도 | 단순 누락/형식 오류 (최대 횟수 명시) |
| 에스컬레이션 | 판단 불확실 → 사람에게 확인 |
| 스킵 + 로그 | 선택적 단계, 전체 흐름에 무영향 |

---

### 3. 툴 & 워크플로우 설계

#### 스킬 / MCP 선정

> **실제 검색과 설치는 refine 단계(`/project-launch:refine`)에서 Claude Code가 수행한다.**
> 이 섹션에서는 프로젝트에 필요한 검색 키워드만 정리한다.

P0/P1 핵심 기능별로 어떤 전문 스킬이나 MCP가 도움될지 키워드로 정리:

| 기능 | 검색 키워드 | 예상 필요 (스킬/MCP) |
|------|-----------|---------------------|
| (예: 영상 생성) | remotion, video | (있을 것으로 예상 / 직접 구현 예정) |

> **섹션 5 연동:** 섹션 5 "외부 서비스 목록"에 서비스를 추가하면, 해당 서비스명을 이 테이블의 검색 키워드에도 반드시 추가한다.
> 예: 섹션 5에 Stripe를 추가 → 이 테이블에 `| 결제 | stripe, payment | MCP |` 행 추가.

검색 소스·절차·설치는 `.claude/skills/skill-discovery/SKILL.md`에 정의되어 있다.
refine 단계에서 이 스킬이 자동 실행되어 결과 테이블이 채워지고, setup 단계에서 설치된다.

산출물: 기능별 검색 키워드 테이블 (refine에서 검색 결과로 업데이트됨)

---

### 4. 구현 설계

#### 기술 스택
- 프레임워크:
- 언어:
- DB:
- 호스팅/배포:
- 주요 라이브러리:

#### 에이전트 구조

프로젝트 규모에 따라 3단계 중 하나를 선택한다:

| Tier | 모드 | 적합한 경우 | 세팅 스킬 생성물 |
|:----:|------|-----------|----------------|
| 1 | **Single** | 기능 3개 이하, 워크플로우 단순 | CLAUDE.md + .claude/ 기본 구성 |
| 2 | **Subagents** | 독립 작업 블록이 있고 컨텍스트 절약 필요 | Tier 1 + `.claude/agents/` 커스텀 에이전트 |
| 3 | **Agent Teams** | 대규모, 에이전트 간 소통 필요, 병렬 세션 | Tier 2 + worktree 가이드 + 팀 구성 안내 |

**Tier 선택 기준 (Claude Code 공식 가이드):**
- Tier 1 → 2 전환: 작업이 독립적이고 결과만 필요할 때 (테스트, 리뷰, 탐색 등)
- Tier 2 → 3 전환: 서브에이전트로 컨텍스트 한계를 치거나, 에이전트끼리 소통이 필요할 때

**Tier 2 (Subagents) 사용 시:**
- 메인(CLAUDE.md)이 오케스트레이터
- 서브에이전트 간 직접 호출 금지 → 메인을 통해 조율
- 각 에이전트: 이름, 역할, 입출력, 참조 스킬 명시
- `isolation: worktree` 옵션으로 파일 충돌 방지 가능

**Tier 3 (Agent Teams) 사용 시:**
- 실험 기능 (`CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS` 활성화 필요)
- 팀 리드가 TeamCreate → 태스크 분배 → 결과 통합
- 각 팀원은 독립 Claude Code 세션 (worktree 필수)
- 팀원 간 SendMessage로 직접 소통 가능

#### 스킬 목록

> 이 프로젝트만의 **도메인 전용 스킬**만 정의한다.
> 범용 스킬(error-handling, testing, security, conventions 등)은 세팅 스킬이 자동 포함하므로 여기에 쓰지 않는다.
> 여기에 정의된 스킬은 세팅 시 `.claude/skills/{스킬명}/SKILL.md`로 자동 생성된다.

| 스킬명 | 역할 | 트리거 조건 | user-invocable |
|--------|------|------------|:--------------:|
| (예: image-generation) | (나노바나나프로 이미지 생성) | (이미지 생성·편집 작업 시) | false |

스킬 vs 서브에이전트 구분:
| 스킬 | 서브에이전트 |
|------|-------------|
| 도구/기능 단위 (작음) | 역할/책임 단위 (큼) |
| 여러 에이전트가 공유 가능 | 특정 워크플로우 전용 |

#### 폴더 구조

세팅 스킬이 자동 생성하므로 여기서는 정의하지 않는다.
프로젝트 소스코드의 주요 디렉토리만 간단히 명시:
- (예: src/app, src/services, src/lib 등 핵심 경로만)

#### 데이터 전달 패턴

| 방식 | 사용 시점 |
|------|----------|
| 파일 기반 | 데이터가 크거나 구조화 → `/output/step1_result.json` |
| 프롬프트 인라인 | 데이터가 작고 단순 |

#### 에러 전략
- 서비스별 fallback 방식
- 사용자 에러 vs 내부 로그 에러

#### 의존성 호환성 메모
비표준 조합 경고 (예: Remotion + Next.js). 없으면 생략.

---

### 5. 기술 결정 (선택)

> 선호가 있으면 채운다. 없으면 비워두고, 세팅 스킬이 스택에 맞게 기본값 적용.

#### 추천 서비스 스택 (기본값)

아래는 검증된 조합이다. **사용자가 선호를 말하지 않으면 이 스택을 기본 추천한다.**
사용자가 대안을 원하면 괄호 안의 대안 중 선택.

| 카테고리 | 추천 (기본값) | 대안 | 비고 |
|---------|:----------:|------|------|
| **프레임워크** | Next.js | Nuxt, SvelteKit, Astro | App Router 기본 |
| **백엔드/DB** | Supabase | Firebase, PlanetScale, Neon | Postgres + Auth + Storage 통합 |
| **배포** | Vercel | Netlify, Cloudflare Pages, Railway | Next.js와 최적 호환 |
| **인증** | Clerk | Supabase Auth, NextAuth, Lucia | 소셜 로그인 + 관리 대시보드 |
| **결제** | Stripe | Toss Payments, Paddle, Lemon Squeezy | 글로벌: Stripe, 국내: Toss |
| **이메일** | Resend | SendGrid, Postmark, Nodemailer | React Email 호환 |
| **DNS/CDN** | Cloudflare | Route53, Namecheap | 무료 DNS + DDoS 방어 |
| **분석** | PostHog | Google Analytics, Mixpanel, Plausible | 오픈소스, 셀프호스팅 가능 |
| **에러 추적** | Sentry | LogRocket, Bugsnag | 프론트+백 에러 통합 |
| **캐시/큐** | Upstash Redis | Redis Cloud, Momento | 서버리스 Redis |
| **벡터 DB** | Pinecone | Weaviate, Qdrant, Supabase pgvector | RAG/검색용 |
| **버전 관리** | GitHub | GitLab, Bitbucket | Claude Code 네이티브 연동 |

#### UI 도구 + 폼 처리
- 컴포넌트 라이브러리: (shadcn (추천) / Radix / MUI / 직접 구현 / 미정)
- 폼 라이브러리: (react-hook-form (추천) / 서버 액션 / 미정)
- 밸리데이션: (zod (추천) / joi / 미정)

#### 데이터 흐름 패턴
- 서버 상태: (React Query (추천) / SWR / 서버 컴포넌트 / 미정)
- 전역 상태: (Zustand (추천) / Jotai / 불필요 / 미정)
- 실시간: (WebSocket / polling / 불필요 / 미정)

#### URL 구조
- 라우팅 패턴: (파일 기반 / 커스텀 / 미정)
- 필터/정렬: (URL searchParams / 상태 / 미정)

#### 외부 서비스 목록

> 위 추천 스택에서 프로젝트에 필요한 서비스를 선택하여 채운다.

| 서비스 | 용도 | API 종류 | 비고 |
|--------|------|----------|------|
| (예: Stripe) | (결제) | (REST) | (sandbox 키 필요) |

상세(웹훅, rate limit 등)는 개발 중 확인.

---

### 6. 구현 순서

> **이 섹션은 섹션 1–5의 종합이다.**
> 앞에서 정의한 기능(섹션 1), 검증 방법(섹션 2), 외부 도구(섹션 3), 에이전트·스킬·폴더 구조(섹션 4), 외부 서비스(섹션 5)를 Phase별 실행 계획으로 조립한다.
> "만들 것"만 나열하지 말 것 — **누가(에이전트), 어떤 도구로(스킬), 어디에(폴더), 어떻게 검증하는지(완료 기준)**까지 명시한다.

의존 관계를 고려한 빌드 로드맵:

```
Phase 1: [기반] → (무엇을 먼저 만드는가)
Phase 2: [핵심] → (P0 기능)
Phase 3: [확장] → (P1 기능)
Phase 4: [마무리] → (P2 + 배포)
```

각 Phase에서:
- 만들 것 목록 — 각 항목에 아래를 포함:
  - **담당 에이전트** (섹션 4 에이전트 구조에서. Tier 1이면 생략)
  - **활용 스킬** (섹션 4 스킬 목록에서. 해당 없으면 생략)
  - **파일 위치** (섹션 4 폴더 구조에서)
  - **외부 서비스** (섹션 5에서. 해당 없으면 생략)
- 선행 의존성 (이전 Phase의 뭐가 있어야 하는가)
- 완료 기준 + 검증 방법 (섹션 2 단계별 검증에서)

---

## 설계 원칙 참고

계획서 작성 시 다음 원칙을 따른다:

### CLAUDE.md, SKILL.md 등의 상세 내용은 작성하지 않는다
계획서는 "무엇을, 어떤 구조로" 수준까지. 파일 내용은 project-launch 스킬이 생성.

### 빈칸/TODO를 남기지 않는다
정보가 없으면 합리적 판단으로 채우고 [추정] 표시.
단, 기술 결정(선택) 섹션은 "미정"이 허용됨.

### 기능별 에러 시나리오를 반드시 포함한다

### 범위 밖 섹션을 반드시 작성한다
스코프 크리프 방지.

---

## 진행 방식

### 1단계: 인터뷰

사용자 입력을 받으면 아래 영역의 정보가 충분한지 판단한다.
**부족한 영역이 있으면 해당 영역의 질문만 한다. 충분하면 바로 작성에 착수한다.**

| 영역 | 확인할 것 | 부족할 때 질문 예시 |
|------|----------|-------------------|
| **제품 목적** | 뭘 만드는지, 왜, 누가 쓰는지 명확한가? | "이걸 주로 누가 쓰게 되나요?" |
| **핵심 기능** | 구체적 기능 3개 이상, 우선순위가 있는가? | "가장 먼저 동작해야 하는 핵심 기능은?" |
| **기술 스택** | 프레임워크, DB, 배포 환경 선호가 있는가? | "기술 스택 선호가 있나요? 없으면 추천할게요" |
| **작업 절차** | 입력→출력까지의 단계, 분기 조건이 있는가? | "A 후에 B로 갈지 C로 갈지 기준이 뭔가요?" |
| **제약/범위** | 예산, 기간, 안 만들 것이 명확한가? | "이번에 명확하게 '안 만들 것'이 있나요?" |

### 질문 원칙

- **한 번에 최대 3개까지만** 질문
- "모르겠다" → 합리적 기본값 제안 + 근거 명시
- "알아서 해줘" → 기본값 적용하되, **핵심 선택지만** 확인 (인증 방식, DB 등)
- 이미 충분한 영역은 질문 안 함
- **뻔한 질문 금지** — "목표가 뭔가요?" 대신 구체적 분기점 질문
- 인터뷰 **1-3회 라운드**로 끝냄

### 2단계: 작성

인터뷰가 끝나면 계획서를 작성한다.
- 빈칸/TODO 남기지 않음 (기술 결정 섹션의 "미정" 제외)
- [추정] 표시로 불확실한 부분 명시
- 기능별 에러 시나리오 반드시 포함
- 범위 밖 섹션 반드시 작성

### 3단계: 리뷰

초안을 제시하고:
- "이 설계에서 가장 불확실한 부분"을 스스로 지적
- 수정 요청 시 해당 부분만 수정
- 최종 확인 후 파일로 저장
