---
description: 프로젝트 계획서 작성 프롬프트 출력. claude.ai에서 사용. 프롬프트 내용을 출력하면 사용자가 claude.ai에 붙여넣는다.
---

# 프로젝트 계획서 작성

이 커맨드는 **claude.ai**에서 사용할 프로젝트 계획서 작성 프롬프트를 출력한다.

## 사용 방법

1. 아래 프롬프트를 사용자에게 보여준다
2. 사용자가 **프로젝트 이름**과 **프로젝트 개요**를 채운다
3. 사용자가 전체를 **claude.ai 채팅창**에 붙여넣고 대화를 통해 계획서를 완성한다
4. 완성된 계획서를 **project-plan.md**로 저장하고 프로젝트 폴더 루트에 넣는다

사용자에게 아래 프롬프트를 출력하라:

---

나는 [프로젝트 이름]을 만들려고 해. 대략의 프로젝트 개요는 다음과 같아.

## 프로젝트 개요
- 수행 작업:
- 워크플로우:


## 최종 산출물

1개의 md 파일 **project-plan.md** — 제품 정의부터 구현 설계까지 담긴 통합 계획서.
이 문서는 claude-code-project-setup 플러그인의 입력으로 사용된다.

## 계획서에 포함될 내용

### 1. 제품 컨텍스트

#### 한 줄 요약
이 프로젝트가 뭔지 한 문장.

#### 배경 및 목적
- 왜 만드는가? 어떤 문제를 해결하는가?
- 사용자는 누구인가? (역할이 여러 개면 각각 정의)

#### 핵심 기능 (3-7개)
기능별로:
- 기능명
- 설명 (1-2문장)
- 사용자 시나리오 (누가, 언제, 어떻게)
- 성공 기준 (구체적, 검증 가능 — "잘 동작한다" ❌ → "3초 내 응답" ✅)
- 우선순위 (P0 필수 / P1 중요 / P2 있으면 좋음)

#### 성공 기준 (Done의 정의)
이 체크리스트가 전부 ✅이면 MVP 완성:
- (P0 기능별 검증 가능한 조건)
- (비기능 충족 조건)

#### 비기능 요구사항
해당하는 것만: 성능, 보안, 접근성, SEO, 확장성

#### 범위 밖
이번에 명시적으로 안 만드는 것.

---

### 2. 워크플로우 정의

#### 사용자 플로우
[시작] → [단계1] → [단계2] → ... → [완료]
주요 분기점과 조건을 명시.

#### 에이전트 (LLM) 판단 vs 스크립트 (Claude Code)처리

| 에이전트가 직접 수행 | 스크립트로 처리 |
|---------------------|----------------|
| 분류, 의사결정, 우선순위 판단 | 파일 I/O, 데이터 파싱 |
| 품질 평가, 정성적 분석 | 외부 API 호출 |
| 컨텍스트 기반 추론 | 반복 처리, 집계 |
| 자연어 생성/요약 | 정적 분석, 테스트 실행 |

#### 단계별 검증

각 워크플로우 단계에 성공 기준 + 검증 방법 + 실패 처리를 명시.

검증 유형:
| 유형 | 적용 대상 | 예시 |
|------|----------|------|
| 스키마 검증 | 구조화된 산출물 | 필수 필드 존재, 타입 체크 |
| 규칙 기반 | 정량 기준이 있는 작업 | 항목 수, 글자 수 |
| LLM 자기 검증 | 정성적 판단 작업 | 요약 품질, 톤 적합성 |
| 사람 검토 | 고위험 최종 산출물 | 외부 발송 문서 |

실패 처리:
| 방식 | 사용 시점 |
|------|----------|
| 자동 재시도 | 단순 누락/형식 오류 (최대 횟수 명시) |
| 에스컬레이션 | 판단 불확실 → 사람에게 확인 |
| 스킵 + 로그 | 선택적 단계, 전체 흐름에 무영향 |

---

### 3. 툴 & 워크플로우 설계

#### MCP 서버 선정

기술 스택이 정해지면 아래 레퍼런스를 클론하여 검색하고 적합한 MCP 서버를 선정한다:
```bash
git clone --depth 1 https://github.com/johunsang/vive-md.git /tmp/vive-md
```
- **서버 카탈로그**: `/tmp/vive-md/vibe-coding/mcp/04-MCP-서버-카탈로그.md` — 스택별 추천 매트릭스 + 조합 레시피
- **설정 패턴**: `/tmp/vive-md/vibe-coding/mcp/03-MCP-실전-패턴-모음.md` — 검증된 `.mcp.json` 설정 복사
- **트러블슈팅**: `/tmp/vive-md/vibe-coding/mcp/README.md` (섹션 9) — 설정 오류 해결

산출물: 확정된 `.mcp.json`

#### 스킬 선정

**P0/P1 핵심 기능별로 전문 스킬이 있는지 반드시 검색한다.**
검색하지 않고 "직접 구현하면 됩니다"로 넘어가는 것은 금지.

검색 절차:
1. 위에서 클론한 vive-md 레포의 스킬 카탈로그를 검색:
   - `/tmp/vive-md/vibe-coding/resources/Awesome-Claude-Skills-한국어-가이드.md` — 380개+ 스킬 탐색
2. 각 P0/P1 기능의 핵심 키워드로 검색 (예: "PDF", "email", "payment", "auth", "image")
3. 검색 결과를 아래 형식으로 정리:

| 기능 | 검색 키워드 | 검색 결과 | 선택 |
|------|-----------|----------|------|
| (예: PDF 생성) | pdf, document, report | (찾은 스킬 이름 또는 "해당 없음") | (설치 / 직접 구현 + 이유) |

4. 검색 결과가 없거나 부적합하면 "해당 없음 — 직접 구현" 으로 명시. 검색 자체를 생략하지 말 것.

스킬 작성 참조: `/tmp/vive-md/vibe-coding/skills/` — 커스텀 스킬 작성 시 구조/패턴

**필수 규칙: 프론트엔드가 포함된 프로젝트면 ui-ux-pro-max 스킬을 무조건 설치한다.**
```bash
git clone --depth 1 https://github.com/nextlevelbuilder/ui-ux-pro-max-skill.git /tmp/ui-ux-pro-max-skill
cp -r /tmp/ui-ux-pro-max-skill/.claude/skills/ui-ux-pro-max .claude/skills/
rm -rf /tmp/ui-ux-pro-max-skill
```

산출물: 기능별 스킬 검색 결과 테이블 + 설치할 스킬 목록 + 설치 명령어

---

### 4. 구현 설계

#### 기술 스택
- 프레임워크:
- 언어:
- DB:
- 호스팅/배포:
- 주요 라이브러리:

#### 에이전트 구조

프로젝트 규모에 따라 3단계 중 하나를 선택한다:

| Tier | 모드 | 적합한 경우 | 세팅 스킬 생성물 |
|:----:|------|-----------|----------------|
| 1 | **Single** | 기능 3개 이하, 워크플로우 단순 | CLAUDE.md + .claude/ 기본 구성 |
| 2 | **Subagents** | 독립 작업 블록이 있고 컨텍스트 절약 필요 | Tier 1 + `.claude/agents/` 커스텀 에이전트 |
| 3 | **Agent Teams** | 대규모, 에이전트 간 소통 필요, 병렬 세션 | Tier 2 + worktree 가이드 + 팀 구성 안내 |

**Tier 선택 기준 (Claude Code 공식 가이드):**
- Tier 1 → 2 전환: 작업이 독립적이고 결과만 필요할 때 (테스트, 리뷰, 탐색 등)
- Tier 2 → 3 전환: 서브에이전트로 컨텍스트 한계를 치거나, 에이전트끼리 소통이 필요할 때

**Tier 2 (Subagents) 사용 시:**
- 메인(CLAUDE.md)이 오케스트레이터
- 서브에이전트 간 직접 호출 금지 → 메인을 통해 조율
- 각 에이전트: 이름, 역할, 입출력, 참조 스킬 명시
- `isolation: worktree` 옵션으로 파일 충돌 방지 가능

**Tier 3 (Agent Teams) 사용 시:**
- 실험 기능 (`CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS` 활성화 필요)
- 팀 리드가 TeamCreate → 태스크 분배 → 결과 통합
- 각 팀원은 독립 Claude Code 세션 (worktree 필수)
- 팀원 간 SendMessage로 직접 소통 가능

#### 스킬 목록

> 이 프로젝트만의 **도메인 전용 스킬**만 정의한다.
> 범용 스킬(error-handling, testing, security, conventions 등)은 세팅 플러그인이 자동 포함하므로 여기에 쓰지 않는다.
> 여기에 정의된 스킬은 세팅 시 `.claude/skills/{스킬명}/SKILL.md`로 자동 생성된다.

| 스킬명 | 역할 | 트리거 조건 | user-invocable |
|--------|------|------------|:--------------:|
| (예: image-generation) | (나노바나나프로 이미지 생성) | (이미지 생성·편집 작업 시) | false |

스킬 vs 서브에이전트 구분:
| 스킬 | 서브에이전트 |
|------|-------------|
| 도구/기능 단위 (작음) | 역할/책임 단위 (큼) |
| 여러 에이전트가 공유 가능 | 특정 워크플로우 전용 |

#### 폴더 구조

세팅 플러그인이 자동 생성하므로 여기서는 정의하지 않는다.
프로젝트 소스코드의 주요 디렉토리만 간단히 명시:
- (예: src/app, src/services, src/lib 등 핵심 경로만)

#### 데이터 전달 패턴

| 방식 | 사용 시점 |
|------|----------|
| 파일 기반 | 데이터가 크거나 구조화 → `/output/step1_result.json` |
| 프롬프트 인라인 | 데이터가 작고 단순 |

#### 에러 전략
- 서비스별 fallback 방식
- 사용자 에러 vs 내부 로그 에러

#### 의존성 호환성 메모
비표준 조합 경고 (예: Remotion + Next.js). 없으면 생략.

---

### 5. 기술 결정 (선택)

> 선호가 있으면 채운다. 없으면 비워두고, 세팅 플러그인이 스택에 맞게 기본값 적용.

#### 추천 서비스 스택 (기본값)

아래는 검증된 조합이다. **사용자가 선호를 말하지 않으면 이 스택을 기본 추천한다.**
사용자가 대안을 원하면 괄호 안의 대안 중 선택.

| 카테고리 | 추천 (기본값) | 대안 | 비고 |
|---------|:----------:|------|------|
| **프레임워크** | Next.js | Nuxt, SvelteKit, Astro | App Router 기본 |
| **백엔드/DB** | Supabase | Firebase, PlanetScale, Neon | Postgres + Auth + Storage 통합 |
| **배포** | Vercel | Netlify, Cloudflare Pages, Railway | Next.js와 최적 호환 |
| **인증** | Clerk | Supabase Auth, NextAuth, Lucia | 소셜 로그인 + 관리 대시보드 |
| **결제** | Stripe | Toss Payments, Paddle, Lemon Squeezy | 글로벌: Stripe, 국내: Toss |
| **이메일** | Resend | SendGrid, Postmark, Nodemailer | React Email 호환 |
| **DNS/CDN** | Cloudflare | Route53, Namecheap | 무료 DNS + DDoS 방어 |
| **분석** | PostHog | Google Analytics, Mixpanel, Plausible | 오픈소스, 셀프호스팅 가능 |
| **에러 추적** | Sentry | LogRocket, Bugsnag | 프론트+백 에러 통합 |
| **캐시/큐** | Upstash Redis | Redis Cloud, Momento | 서버리스 Redis |
| **벡터 DB** | Pinecone | Weaviate, Qdrant, Supabase pgvector | RAG/검색용 |
| **버전 관리** | GitHub | GitLab, Bitbucket | Claude Code 네이티브 연동 |

#### UI 도구 + 폼 처리
- 컴포넌트 라이브러리: (shadcn (추천) / Radix / MUI / 직접 구현 / 미정)
- 폼 라이브러리: (react-hook-form (추천) / 서버 액션 / 미정)
- 밸리데이션: (zod (추천) / joi / 미정)

#### 데이터 흐름 패턴
- 서버 상태: (React Query (추천) / SWR / 서버 컴포넌트 / 미정)
- 전역 상태: (Zustand (추천) / Jotai / 불필요 / 미정)
- 실시간: (WebSocket / polling / 불필요 / 미정)

#### URL 구조
- 라우팅 패턴: (파일 기반 / 커스텀 / 미정)
- 필터/정렬: (URL searchParams / 상태 / 미정)

#### 외부 서비스 목록

> 위 추천 스택에서 프로젝트에 필요한 서비스를 선택하여 채운다.

| 서비스 | 용도 | API 종류 | 비고 |
|--------|------|----------|------|
| (예: Stripe) | (결제) | (REST) | (sandbox 키 필요) |

상세(웹훅, rate limit 등)는 개발 중 확인.

---

### 6. 구현 순서

의존 관계를 고려한 빌드 로드맵:

```
Phase 1: [기반] → (무엇을 먼저 만드는가)
Phase 2: [핵심] → (P0 기능)
Phase 3: [확장] → (P1 기능)
Phase 4: [마무리] → (P2 + 배포)
```

각 Phase에서:
- 만들 것 목록
- 선행 의존성 (이전 Phase의 뭐가 있어야 하는가)
- 완료 기준

---

## 설계 원칙 참고

계획서 작성 시 다음 원칙을 따른다:

### CLAUDE.md, SKILL.md 등의 상세 내용은 작성하지 않는다
계획서는 "무엇을, 어떤 구조로" 수준까지. 파일 내용은 project-setup 플러그인이 생성.

### 빈칸/TODO를 남기지 않는다
정보가 없으면 합리적 판단으로 채우고 [추정] 표시.
단, 기술 결정(선택) 섹션은 "미정"이 허용됨.

### 기능별 에러 시나리오를 반드시 포함한다

### 범위 밖 섹션을 반드시 작성한다
스코프 크리프 방지.

---

## 진행 방식

### 1단계: 인터뷰

사용자 입력을 받으면 아래 영역의 정보가 충분한지 판단한다.
**부족한 영역이 있으면 해당 영역의 질문만 한다. 충분하면 바로 작성에 착수한다.**

| 영역 | 확인할 것 | 부족할 때 질문 예시 |
|------|----------|-------------------|
| **제품 목적** | 뭘 만드는지, 왜, 누가 쓰는지 명확한가? | "이걸 주로 누가 쓰게 되나요?" |
| **핵심 기능** | 구체적 기능 3개 이상, 우선순위가 있는가? | "가장 먼저 동작해야 하는 핵심 기능은?" |
| **기술 스택** | 프레임워크, DB, 배포 환경 선호가 있는가? | "기술 스택 선호가 있나요? 없으면 추천할게요" |
| **작업 절차** | 입력→출력까지의 단계, 분기 조건이 있는가? | "A 후에 B로 갈지 C로 갈지 기준이 뭔가요?" |
| **제약/범위** | 예산, 기간, 안 만들 것이 명확한가? | "이번에 명확하게 '안 만들 것'이 있나요?" |

### 질문 원칙

- **한 번에 최대 3개까지만** 질문
- "모르겠다" → 합리적 기본값 제안 + 근거 명시
- "알아서 해줘" → 기본값 적용하되, **핵심 선택지만** 확인 (인증 방식, DB 등)
- 이미 충분한 영역은 질문 안 함
- **뻔한 질문 금지** — "목표가 뭔가요?" 대신 구체적 분기점 질문
- 인터뷰 **1-3회 라운드**로 끝냄

### 2단계: 작성

인터뷰가 끝나면 계획서를 작성한다.
- 빈칸/TODO 남기지 않음 (기술 결정 섹션의 "미정" 제외)
- [추정] 표시로 불확실한 부분 명시
- 기능별 에러 시나리오 반드시 포함
- 범위 밖 섹션 반드시 작성

### 3단계: 리뷰

초안을 제시하고:
- "이 설계에서 가장 불확실한 부분"을 스스로 지적
- 수정 요청 시 해당 부분만 수정
- 최종 확인 후 파일로 저장
